{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyEventCounter from './KeyEventCounter';\nimport Configuration from '../config/Configuration';\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\nimport KeyEventType from '../../const/KeyEventType';\n/**\n * Handles the propagation of keyboard events up through the React component tree,\n * starting from the hot keys component closest to the event target\n * @class\n */\n\nvar EventPropagator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new instance of EventPropagator\n   * @param {ComponentOptionsList} componentList List of options of the components\n   *        the event is propagating through\n   * @param {Logger} logger The logger instance to use\n   * @param {function} logPrefix Function that returns the appropriate log prefix for\n   *        each log entry\n   * @returns {EventPropagator}\n   */\n  function EventPropagator(componentList, _ref) {\n    var logger = _ref.logger,\n        logPrefix = _ref.logPrefix;\n\n    _classCallCheck(this, EventPropagator);\n\n    this._componentList = componentList;\n    this._previousPropagation = null;\n    this.logger = logger;\n    this._logPrefix = logPrefix;\n\n    this._reset();\n  }\n\n  _createClass(EventPropagator, [{\n    key: \"_reset\",\n    value: function _reset() {\n      /**\n       * Position of the component that the event last propagated through\n       * @type {number}\n       */\n      this._previousPosition = -1;\n      /**\n       * Position of the current component the event is propagating through\n       * @type {number}\n       */\n\n      this._position = -1;\n      /**\n       * Flag to record whether the keyboard event matches an action whose handler\n       * has already been called\n       * @type {boolean}\n       */\n\n      this._actionHandled = false;\n      /**\n       * Flag to record whether the keyboard event should be ignored\n       * @type {boolean}\n       */\n\n      this._ignoreEvent = false;\n      /**\n       * Flag to record whether the keyboard event current being handled should be\n       * observed, even if matches the ignoreEventCondition\n       * @type {boolean}\n       */\n\n      this._observeIgnoredEvents = false;\n      /**\n       * Flag to record whether the event is being stopped from further propagation\n       * @type {boolean}\n       */\n\n      this._stopping = false;\n      /**\n       * The id of the component the event is current propagating through\n       * @type {ComponentId}\n       */\n\n      this._componentId = null;\n      /**\n       * The name of the key the propagating event relates to\n       * @type {ReactKeyName}\n       */\n\n      this._key = null;\n      /**\n       * The type of keyboard event that is propagating\n       * @type {KeyEventType}\n       */\n\n      this._type = null;\n    }\n    /********************************************************************************\n     * New event propagation\n     *********************************************************************************/\n\n    /**\n     * Whether the current propagation step is the first one\n     * @returns {boolean} true if this is the first propagation step\n     */\n\n  }, {\n    key: \"isFirstPropagationStep\",\n    value: function isFirstPropagationStep() {\n      var previousPosition = this.getPreviousPosition();\n      return previousPosition === -1 || previousPosition >= this._position;\n    }\n    /**\n     * Whether the propagation is for a particular key\n     * @param {ReactKeyName} keyName The name of the key to query\n     * @returns {boolean} true if the event propagation is for the key\n     */\n\n  }, {\n    key: \"isForKey\",\n    value: function isForKey(keyName) {\n      return this._key === keyName;\n    }\n    /**\n     * The type of keyboard event that is propagating\n     * @param {KeyEventType} keyEventType The type of keyboard event to query\n     * @returns {boolean} true if the keyboard event propagating is that type\n     */\n\n  }, {\n    key: \"isForEventType\",\n    value: function isForEventType(keyEventType) {\n      return this._type === keyEventType;\n    }\n    /********************************************************************************\n     * Propagation steps\n     *********************************************************************************/\n\n    /**\n     * Begin a new propagation step, called as a before callback. i.e. the first thing\n     * after an event has propagated to a new hot keys component\n     * @param {ComponentId} componentId The id of the component that has just had the\n     *        event propagate up to it\n     * @param {KeyboardEvent} event The actual KeyboardEvent that is propagating\n     * @param {ReactKeyName} key The name of the key the event relates to\n     * @param {KeyEventType} type The type of keyboard event\n     * @returns {boolean} true if the event should be observed, otherwise false if it\n     *        should be ignored.\n     */\n\n  }, {\n    key: \"startNewPropagationStep\",\n    value: function startNewPropagationStep(componentId, event, key, type) {\n      this._position = this._componentList.getIndexById(componentId);\n      this._componentId = componentId;\n\n      if (this.isFirstPropagationStep()) {\n        KeyEventCounter.incrementId();\n        this._key = event.key;\n        this._type = type;\n      }\n\n      if (event.repeat && Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored repeated \".concat(describeKeyEvent(event, key, KeyEventType.keydown), \" event.\"));\n        this.ignoreEvent(event);\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Ends handling of a propagation step and performs cleanup. Called as a after callback.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"finishPropagationStep\",\n    value: function finishPropagationStep() {\n      if (this.isStopped() || this._componentList.isRoot(this._componentId)) {\n        this._previousPropagation = this._clone();\n\n        this._reset();\n      } else {\n        this._previousPosition = this._position;\n      }\n    }\n    /********************************************************************************\n     * Previous propagation\n     *********************************************************************************/\n\n    /**\n     * The previous event propagation, either for an earlier event type of the same key\n     * or a different key's event propagation\n     * @returns {EventPropagator} The propagator for the previous event propagation\n     */\n\n  }, {\n    key: \"getPreviousPropagation\",\n    value: function getPreviousPropagation() {\n      if (!this._previousPropagation) {\n        this._previousPropagation = this._clone({\n          copyState: false\n        });\n      }\n\n      return this._previousPropagation;\n    }\n    /**\n     * The position of the component that last had the current propagating event\n     * propagate through it\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getPreviousPosition\",\n    value: function getPreviousPosition() {\n      return this._previousPosition;\n    }\n    /********************************************************************************\n     * Ignoring events\n     *********************************************************************************/\n\n    /**\n     * Set the observeIgnoredEvents flag, to observe (not ignore) keyboard events that\n     * match the ignored events filter\n     * @returns {void}\n     */\n\n  }, {\n    key: \"observeIgnoredEvents\",\n    value: function observeIgnoredEvents() {\n      this._observeIgnoredEvents = true;\n    }\n    /**\n     * Record that an event is being ignored for the rest of its propagation and, if\n     * enabled, stop it from further propagation entirely.\n     * @param {KeyboardEvent} event Event to ignore\n     * @returns {boolean} true if the event was stopped from further propagation,\n     *          otherwise false.\n     */\n\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(event) {\n      this.setIgnoreEvent(true);\n\n      if (this.isIgnoringEvent() && Configuration.option('stopEventPropagationAfterIgnoring')) {\n        this.logger.debug(this._logPrefix(this._componentId), 'Stopping further event propagation.');\n        this.stop(event);\n        this.finishPropagationStep();\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Set the ignore event flag, to ignore the current event for the rest of its\n     * propagation\n     * @param {boolean} ignore true to ignore the event, or false to not ignore it\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setIgnoreEvent\",\n    value: function setIgnoreEvent(ignore) {\n      this._ignoreEvent = ignore;\n    }\n    /**\n     * Whether to ignore the currently propagating event or not\n     * @returns {boolean} true if the event is being ignored for the current propagation\n     */\n\n  }, {\n    key: \"isIgnoringEvent\",\n    value: function isIgnoringEvent() {\n      return !this._observeIgnoredEvents && this._ignoreEvent;\n    }\n    /********************************************************************************\n     * Stopping propagation\n     *********************************************************************************/\n\n    /**\n     * Whether the event has been stopped from further propagation\n     * @returns {boolean} true if the event is being stopped\n     */\n\n  }, {\n    key: \"isStopped\",\n    value: function isStopped() {\n      return this._stopping;\n    }\n    /**\n     * Stop an event from further propagation\n     * @param {KeyboardEvent} event Event to call stopPropagation() on\n     * @returns {boolean} true if the event was stopped and false if it was already\n     *          stopped\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(event) {\n      if (!this.isStopped()) {\n        this._stopping = true; // noinspection JSUnresolvedVariable\n\n        if (!event.simulated) {\n          event.stopPropagation();\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Whether the keyboard event has yet propagated to the root hot keys component\n     * @returns {boolean} true if it still has hotkeys components to propagate to\n     *          before being complete.\n     */\n\n  }, {\n    key: \"isPendingPropagation\",\n    value: function isPendingPropagation() {\n      var previousPosition = this.getPreviousPosition();\n      return previousPosition !== -1 && previousPosition + 1 < this._position;\n    }\n    /**\n     * If the action has already been handled\n     * @returns {boolean} true if the action has already been handled\n     */\n\n  }, {\n    key: \"isHandled\",\n    value: function isHandled() {\n      return this._actionHandled;\n    }\n    /**\n     * Record that the current propagating event matched and action and its handler\n     * has been called.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"setHandled\",\n    value: function setHandled() {\n      this._actionHandled = true;\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$copyState = _ref2.copyState,\n          copyState = _ref2$copyState === void 0 ? true : _ref2$copyState;\n\n      var cloned = new EventPropagator(this._componentList, {\n        logger: this.logger,\n        logPrefix: this._logPrefix\n      });\n\n      if (copyState) {\n        Object.assign(cloned, this);\n      }\n\n      return cloned;\n    }\n  }]);\n\n  return EventPropagator;\n}();\n\nexport default EventPropagator;","map":null,"metadata":{},"sourceType":"module"}