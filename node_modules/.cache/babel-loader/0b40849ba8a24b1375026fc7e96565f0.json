{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport Configuration from '../config/Configuration';\nimport size from '../../utils/collection/size';\nimport keyupIsHiddenByCmd from '../../helpers/resolving-handlers/keyupIsHiddenByCmd';\n/**\n * Object containing all information necessary to match a handler to a history of\n * key combinations\n * @typedef {Object} MatchingActionConfig\n * @property {NormalizedKeySequenceId} prefix - String describing the sequence of key\n *          combinations, before the final key combination (an empty string for\n *          sequences that are a single key combination)\n * @property {number} sequenceLength - Number of combinations involved in the\n *           sequence\n * @property {KeyCombinationString} id - Serialized description of the key combinations\n *            that make up the sequence\n * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\n *           in the last key combination of the sequence\n * @property {KeyEventType} keyEventType - Record index for key event that\n *          the matcher should match on\n * @property {number} size - Number of keys involved in the final key combination\n * @property {EventMatchDictionary} events - Dictionary of EventMatches\n */\n\n/**\n * A dictionary mapping key event types to event matches\n * @typedef {Object.<KeyEventType, EventMatch>} EventMatchDictionary\n */\n\n/**\n * Object containing information to call a handler if an event type matches a\n * key event\n * @typedef {Object} EventMatch\n * @property {ActionName} actionName - Name of the action\n * @property {Function} handler - Handler to call if event type matches\n */\n\n/**\n * Matches a KeyCombination to a list of pre-registered ActionConfiguration and their\n * corresponding handler functions\n * @class\n */\n\nvar KeyCombinationMatcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Returns a new instance of KeyCombinationMatcher\n   * @returns {KeyCombinationMatcher}\n   */\n  function KeyCombinationMatcher() {\n    _classCallCheck(this, KeyCombinationMatcher);\n\n    this._actionConfigs = {};\n    this._order = null;\n  }\n  /**\n   * Adds a new ActionConfiguration and handler to those that can be used to match a\n   * KeyCombination\n   * @param {ActionConfiguration} actionConfig\n   * @param {Function} handler Function to call if match is selected\n   * @returns {void}\n   */\n\n\n  _createClass(KeyCombinationMatcher, [{\n    key: \"addMatch\",\n    value: function addMatch(actionConfig, handler) {\n      if (this._includesMatcherForCombination(actionConfig.id)) {\n        var keyEventType = actionConfig.keyEventType,\n            actionName = actionConfig.actionName,\n            id = actionConfig.id;\n\n        this._addHandlerToActionConfig(id, {\n          keyEventType: keyEventType,\n          actionName: actionName,\n          handler: handler\n        });\n      } else {\n        this._addNewActionConfig(actionConfig, handler);\n      }\n    }\n    /**\n     * Finds a MatchingActionConfig for a KeyCombination, ReactKeyName and\n     * KeyEventType\n     * @param {KeyCombination} keyCombination Record of key combinations\n     *         to use in the match\n     * @param {ReactKeyName} keyName Name of the key to use in the match\n     * @param {KeyEventType} keyEventType The type of key event to use in the match\n     * @returns {MatchingActionConfig|null} A MatchingActionOptions that matches the\n     *          KeyCombination, ReactKeyName and KeyEventType\n     */\n\n  }, {\n    key: \"findMatch\",\n    value: function findMatch(keyCombination, keyName, keyEventType) {\n      if (!this._order) {\n        this._setOrder();\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._order[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var combinationId = _step.value;\n          var actionOptions = this._actionConfigs[combinationId];\n\n          if (this._matchesActionConfig(keyCombination, keyName, keyEventType, actionOptions)) {\n            return actionOptions;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    }\n    /********************************************************************************\n     * Presentation\n     ********************************************************************************/\n\n    /**\n     * A plain JavaScript representation of the KeyCombinationMatcher, useful for\n     * serialization or debugging\n     * @returns {Object} Serialized representation of the key combination matcher\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        actionConfigs: this._actionConfigs,\n        order: this._order\n      };\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_matchesActionConfig\",\n    value: function _matchesActionConfig(keyCombination, keyName, keyEventType, actionOptions) {\n      if (!canBeMatched(keyCombination, actionOptions)) {\n        return false;\n      }\n\n      var combinationHasHandlerForEventType = actionOptions.events[keyEventType];\n\n      if (!combinationHasHandlerForEventType) {\n        /**\n         * If the combination does not have any actions bound to the key event we are\n         * currently processing, we skip checking if it matches the current keys being\n         * pressed.\n         */\n        return false;\n      }\n\n      var keyCompletesCombination = false;\n      var combinationMatchesKeysPressed = Object.keys(actionOptions.keyDictionary).every(function (candidateKeyName) {\n        if (keyCombination.isEventTriggered(candidateKeyName, keyEventType)) {\n          if (keyName && keyName === keyCombination.getNormalizedKeyName(candidateKeyName)) {\n            keyCompletesCombination = !keyCombination.wasEventPreviouslyTriggered(candidateKeyName, keyEventType);\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      });\n      return combinationMatchesKeysPressed && keyCompletesCombination;\n    }\n  }, {\n    key: \"_setOrder\",\n    value: function _setOrder() {\n      /**\n       * The first time the component that is currently handling the key event has\n       * its handlers searched for a match, order the combinations based on their\n       * size so that they may be applied in the correct priority order\n       */\n      var combinationsPartitionedBySize = Object.values(this._actionConfigs).reduce(function (memo, _ref) {\n        var id = _ref.id,\n            size = _ref.size;\n\n        if (!memo[size]) {\n          memo[size] = [];\n        }\n\n        memo[size].push(id);\n        return memo;\n      }, {});\n      this._order = Object.keys(combinationsPartitionedBySize).sort(function (a, b) {\n        return b - a;\n      }).reduce(function (memo, key) {\n        return memo.concat(combinationsPartitionedBySize[key]);\n      }, []);\n    }\n  }, {\n    key: \"_addNewActionConfig\",\n    value: function _addNewActionConfig(combinationSchema, handler) {\n      var prefix = combinationSchema.prefix,\n          sequenceLength = combinationSchema.sequenceLength,\n          id = combinationSchema.id,\n          keyDictionary = combinationSchema.keyDictionary,\n          size = combinationSchema.size,\n          keyEventType = combinationSchema.keyEventType,\n          actionName = combinationSchema.actionName;\n\n      this._setCombinationMatcher(id, {\n        prefix: prefix,\n        sequenceLength: sequenceLength,\n        id: id,\n        keyDictionary: keyDictionary,\n        size: size,\n        events: {}\n      });\n\n      this._addHandlerToActionConfig(id, {\n        keyEventType: keyEventType,\n        actionName: actionName,\n        handler: handler\n      });\n    }\n  }, {\n    key: \"_addHandlerToActionConfig\",\n    value: function _addHandlerToActionConfig(id, _ref2) {\n      var keyEventType = _ref2.keyEventType,\n          actionName = _ref2.actionName,\n          handler = _ref2.handler;\n\n      var combination = this._getCombinationMatcher(id);\n\n      this._setCombinationMatcher(id, _objectSpread({}, combination, {\n        events: _objectSpread({}, combination.events, _defineProperty({}, keyEventType, {\n          actionName: actionName,\n          handler: handler\n        }))\n      }));\n    }\n  }, {\n    key: \"_setCombinationMatcher\",\n    value: function _setCombinationMatcher(id, combinationMatcher) {\n      this._actionConfigs[id] = combinationMatcher;\n    }\n  }, {\n    key: \"_getCombinationMatcher\",\n    value: function _getCombinationMatcher(id) {\n      return this._actionConfigs[id];\n    }\n  }, {\n    key: \"_includesMatcherForCombination\",\n    value: function _includesMatcherForCombination(id) {\n      return !!this._getCombinationMatcher(id);\n    }\n  }]);\n\n  return KeyCombinationMatcher;\n}();\n\nfunction canBeMatched(keyCombination, combinationMatcher) {\n  var combinationKeysNo = size(combinationMatcher.keyDictionary);\n\n  if (Configuration.option('allowCombinationSubmatches') || keyUpIsBeingHidden(keyCombination)) {\n    return keyCombination.getNumberOfKeys() >= combinationKeysNo;\n  } else {\n    /**\n     * If sub-matches are not allow, the number of keys in the key state and the\n     * number of keys in the combination we are attempting to match, must be\n     * exactly the same\n     */\n    return keyCombination.getNumberOfKeys() === combinationKeysNo;\n  }\n}\n\nfunction keyUpIsBeingHidden(keyCombination) {\n  if (keyCombination.isKeyStillPressed('Meta')) {\n    return keyCombination.some(function (keyName) {\n      return keyupIsHiddenByCmd(keyName);\n    });\n  }\n\n  return false;\n}\n\nexport default KeyCombinationMatcher;","map":null,"metadata":{},"sourceType":"module"}