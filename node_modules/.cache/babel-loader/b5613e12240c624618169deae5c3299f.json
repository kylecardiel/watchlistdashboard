{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport AbstractKeyEventStrategy from './AbstractKeyEventStrategy';\nimport KeyEventType from '../../const/KeyEventType';\nimport KeyEventCounter from '../listening/KeyEventCounter';\nimport describeKeyEventType from '../../helpers/logging/describeKeyEventType';\nimport Configuration from '../config/Configuration';\nimport Logger from '../logging/Logger';\nimport printComponent from '../../helpers/logging/printComponent';\nimport isUndefined from '../../utils/isUndefined';\nimport getKeyName from '../../helpers/resolving-handlers/getKeyName';\nimport isCmdKey from '../../helpers/parsing-key-maps/isCmdKey';\nimport describeKeyEvent from '../../helpers/logging/describeKeyEvent';\nimport EventResponse from '../../const/EventResponse';\nimport KeyEventState from '../../const/KeyEventState';\nimport stateFromEvent from '../../helpers/parsing-key-maps/stateFromEvent';\nimport EventPropagator from '../listening/EventPropagator';\n/**\n * Defines behaviour for dealing with key maps defined in focus-only HotKey components\n * @class\n */\n\nvar FocusOnlyKeyEventStrategy =\n/*#__PURE__*/\nfunction (_AbstractKeyEventStra) {\n  _inherits(FocusOnlyKeyEventStrategy, _AbstractKeyEventStra);\n  /********************************************************************************\n   * Init & Reset\n   ********************************************************************************/\n\n\n  function FocusOnlyKeyEventStrategy() {\n    var _this;\n\n    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var keyEventManager = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, FocusOnlyKeyEventStrategy);\n    /**\n     * Set state that DOES get cleared on each new focus tree\n     */\n\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FocusOnlyKeyEventStrategy).call(this, configuration, keyEventManager));\n    /**\n     * State that doesn't get cleared on each new focus tree\n     */\n\n    /**\n     * Unique identifier given to each focus tree - when the focus in the browser\n     * changes, and a different tree of elements are focused, a new id is allocated\n     * @typedef {number} FocusTreeId\n     */\n\n    /**\n     * Counter to keep track of what focus tree ID should be allocated next\n     * @type {FocusTreeId}\n     */\n\n    _this.focusTreeId = 0;\n    return _this;\n  }\n  /**\n   * Clears the internal state, wiping any history of key events and registered handlers\n   * so they have no effect on the next tree of focused HotKeys components\n   * @private\n   */\n\n\n  _createClass(FocusOnlyKeyEventStrategy, [{\n    key: \"_reset\",\n    value: function _reset() {\n      _get(_getPrototypeOf(FocusOnlyKeyEventStrategy.prototype), \"_reset\", this).call(this);\n\n      this.keypressEventsToSimulate = [];\n      /**\n       * Increase the unique ID associated with each unique focus tree\n       * @type {number}\n       */\n\n      this.focusTreeId += 1;\n      this.eventPropagator = new EventPropagator(this.componentList, {\n        logger: this.logger,\n        logPrefix: this._logPrefix.bind(this)\n      });\n    }\n    /********************************************************************************\n     * Registering key maps and handlers\n     ********************************************************************************/\n\n    /**\n     * Registers the actions and handlers of a HotKeys component that has gained focus\n     * @param {ComponentId} componentId - Id of the component that the keyMap belongs to\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key expressions\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handler functions\n     * @param {Object} options Hash of options that configure how the actions\n     *        and handlers are associated and called.\n     * @returns {FocusTreeId|undefined} The current focus tree's ID or undefined if the\n     *        the <tt>componentId</tt> has already been registered (shouldn't normally\n     *        occur).\n     */\n\n  }, {\n    key: \"enableHotKeys\",\n    value: function enableHotKeys(componentId) {\n      var actionNameToKeyMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var actionNameToHandlersMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (this.resetOnNextFocus) {\n        /**\n         * We know components have just lost focus or keymaps have already been built,\n         * meaning we are either anticipating a new set of components to be focused or\n         * we are receiving notice of a component being focused when we aren't expecting it.\n         * In either case, the internal state needs to be reset.\n         */\n        this._reset();\n\n        this.resetOnNextFocus = false;\n      }\n\n      if (this.componentList.containsId(componentId)) {\n        /**\n         * The <tt>componentId</tt> has already been registered - this occurs when the\n         * same component has somehow managed to be focused twice, without being blurred\n         * in between.\n         *\n         * @see https://github.com/greena13/react-hotkeys/issues/173\n         */\n        return undefined;\n      }\n\n      this._addComponent(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      this.logger.debug(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Focused. \\n');\n      this.logger.verbose(this._logPrefix(componentId, {\n        eventId: false\n      }), 'Component options:\\n', printComponent(this.componentList.get(componentId)));\n      return this.focusTreeId;\n    }\n    /**\n     * Handles when a HotKeys component that is in focus updates its props and changes\n     * either the keyMap or handlers prop value\n     * @param {FocusTreeId} focusTreeId - The ID of the focus tree the component is part of.\n     *        Used to identify (and ignore) stale updates.\n     * @param {ComponentId} componentId - The component index of the component to\n     *        update\n     * @param {KeyMap} actionNameToKeyMap - Map of key sequences to action names\n     * @param {HandlersMap} actionNameToHandlersMap - Map of action names to handler\n     *        functions\n     * @param {Object} options Hash of options that configure how the actions\n     *        and handlers are associated and called.\n     */\n\n  }, {\n    key: \"updateEnabledHotKeys\",\n    value: function updateEnabledHotKeys(focusTreeId, componentId) {\n      var actionNameToKeyMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var actionNameToHandlersMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var options = arguments.length > 4 ? arguments[4] : undefined;\n\n      if (focusTreeId !== this.focusTreeId || !this.componentList.containsId(componentId)) {\n        return;\n      }\n\n      this.componentList.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n      this.getKeyHistory().setMaxLength(this.componentList.getLongestSequence());\n      this.logger.debug(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId,\n        eventId: false\n      }), 'Received new props.');\n      /**\n       * Reset handler resolution state\n       */\n\n      this._initHandlerResolutionState();\n\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId,\n        eventId: false\n      }), 'Component options:\\n', printComponent(this.componentList.get(componentId)));\n    }\n    /**\n     * Handles when a component loses focus by resetting the internal state, ready to\n     * receive the next tree of focused HotKeys components\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's\n     *        apart of\n     * @param {ComponentId} componentId - Index of component that is blurring\n     * @returns {boolean} Whether the component still has event propagation yet to handle\n     */\n\n  }, {\n    key: \"disableHotKeys\",\n    value: function disableHotKeys(focusTreeId, componentId) {\n      if (!this.resetOnNextFocus) {\n        this.resetOnNextFocus = true;\n      }\n\n      var outstandingEventPropagation = this.eventPropagator.isPendingPropagation();\n      this.logger.debug(\"\".concat(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId,\n        eventId: false\n      })), \"Lost focus\".concat(outstandingEventPropagation ? ' (Key event has yet to propagate through it)' : '', \".\"));\n      return outstandingEventPropagation;\n    }\n    /********************************************************************************\n     * Recording key events\n     ********************************************************************************/\n\n    /**\n     * @typedef {KeyboardEvent} SyntheticKeyboardEvent\n     * @property {function} persist\n     */\n\n    /**\n     * Records a keydown keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called many times as a keyboard event bubbles up through the React\n     * render tree. The event is only registered the first time it is seen and results\n     * of some calculations are cached. The event is matched against the handlers registered\n     * at each component level, to ensure the proper handler declaration scoping.\n     * @param {SyntheticKeyboardEvent} event - Event containing the key name and state\n     * @param {FocusTreeId} focusTreeId - Id of focus tree component thinks it's apart of\n     * @param {ComponentId} componentId - The id of the component that is currently handling\n     *        the keyboard event as it bubbles towards the document root.\n     * @param {Object} options - Hash of options that configure how the event is handled.\n     * @returns Whether the event was discarded because it was part of an old focus tree\n     */\n\n  }, {\n    key: \"handleKeydown\",\n    value: function handleKeydown(event, focusTreeId, componentId) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var key = getKeyName(event);\n\n      if (focusTreeId !== this.focusTreeId) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keydown), \" event because it had an old focus tree id: \").concat(focusTreeId, \".\"));\n        this.eventPropagator.ignoreEvent(event);\n        return true;\n      }\n\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keydown);\n\n      if (!started) {\n        return;\n      }\n\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keydown);\n\n      if (responseAction === EventResponse.handled) {\n        var keyEventState = stateFromEvent(event);\n        var currentCombination = this.getCurrentCombination();\n\n        if (currentCombination.isKeyIncluded(key) || currentCombination.isEnding()) {\n          this._startAndLogNewKeyCombination(key, focusTreeId, componentId, keyEventState);\n        } else {\n          this._addToAndLogCurrentKeyCombination(key, KeyEventType.keydown, focusTreeId, componentId, keyEventState);\n        }\n\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keydown, componentId, focusTreeId);\n      }\n\n      this._simulateKeyPressForNonPrintableKeys(event, key, focusTreeId, componentId, options);\n\n      this.eventPropagator.finishPropagationStep();\n      return false;\n    }\n  }, {\n    key: \"_howToHandleKeyEvent\",\n    value: function _howToHandleKeyEvent(event, focusTreeId, componentId, key, options, keyEventType) {\n      if (this.eventPropagator.isFirstPropagationStep()) {\n        if (options.ignoreEventsCondition(event) && this.eventPropagator.ignoreEvent(event)) {\n          return this._eventIsToBeIgnored(event, componentId, key, keyEventType);\n        }\n\n        this.logger.debug(this._logPrefix(componentId), \"New \".concat(describeKeyEvent(event, key, keyEventType), \" event.\"));\n\n        this._checkForModifierFlagDiscrepancies(event, key, keyEventType);\n      } else if (this.eventPropagator.isIgnoringEvent()) {\n        return this._eventIsToBeIgnored(event, componentId, key, keyEventType);\n      }\n\n      return EventResponse.handled;\n    }\n  }, {\n    key: \"_eventIsToBeIgnored\",\n    value: function _eventIsToBeIgnored(event, componentId, key, keyEventType) {\n      this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, keyEventType), \" event because ignoreEventsFilter rejected it.\"));\n      return EventResponse.ignored;\n    }\n    /**\n     * Records a keypress keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called many times as a keyboard event bubbles up through the React\n     * render tree. The event is only registered the first time it is seen and results\n     * of some calculations are cached. The event is matched against the handlers registered\n     * at each component level, to ensure the proper handler declaration scoping.\n     * @param {KeyboardEvent} event - Event containing the key name and state\n     * @param {FocusTreeId} focusTreeId Id - of focus tree component thinks it's apart of\n     * @param {ComponentId} componentId - The index of the component that is currently handling\n     *        the keyboard event as it bubbles towards the document root.\n     * @param {Object} options - Hash of options that configure how the event\n     *        is handled.\n     * @returns {boolean} Whether the HotKeys component should discard its current focus\n     *        tree Id, because it belongs to an old focus tree.\n     */\n\n  }, {\n    key: \"handleKeyPress\",\n    value: function handleKeyPress(event, focusTreeId, componentId, options) {\n      var key = getKeyName(event);\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyPressSimulated(key)) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keypress), \" as it was not expected, and has already been simulated.\"));\n        this.eventPropagator.ignoreEvent(event);\n        return true;\n      }\n\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keypress);\n\n      if (!started) {\n        return;\n      }\n\n      var shouldDiscardFocusTreeId = focusTreeId !== this.focusTreeId;\n      /**\n       * We first decide if the keypress event should be handled (to ensure the correct\n       * order of logging statements)\n       */\n\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keypress);\n\n      if (this.eventPropagator.isFirstPropagationStep(componentId) && currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keypress, focusTreeId, componentId, stateFromEvent(event));\n      }\n      /**\n       * We attempt to find a handler of the event, only if it has not already\n       * been handled and should not be ignored\n       */\n\n\n      if (responseAction === EventResponse.handled) {\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keypress, componentId, focusTreeId);\n      }\n\n      this.eventPropagator.finishPropagationStep();\n      return shouldDiscardFocusTreeId;\n    }\n    /**\n     * Records a keyup keyboard event and matches it against the list of pre-registered\n     * event handlers, calling the first matching handler with the highest priority if\n     * one exists.\n     *\n     * This method is called many times as a keyboard event bubbles up through the React\n     * render tree. The event is only registered the first time it is seen and results\n     * of some calculations are cached. The event is matched against the handlers registered\n     * at each component level, to ensure the proper handler declaration scoping.\n     * @param {KeyboardEvent} event Event containing the key name and state\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\n     * @param {ComponentId} componentId The index of the component that is currently handling\n     *        the keyboard event as it bubbles towards the document root.\n     * @param {Object} options Hash of options that configure how the event\n     *        is handled.\n     * @returns {boolean} Whether HotKeys component should discard its current focusTreeId\n     *        because it's stale (part of an old focus tree)\n     */\n\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event, focusTreeId, componentId, options) {\n      var key = getKeyName(event);\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyUpSimulated(key)) {\n        this.logger.debug(this._logPrefix(componentId), \"Ignored \".concat(describeKeyEvent(event, key, KeyEventType.keyup), \" as it was not expected, and has already been simulated.\"));\n        this.eventPropagator.ignoreEvent(event);\n        return true;\n      }\n\n      var started = this.eventPropagator.startNewPropagationStep(componentId, event, key, KeyEventType.keyup);\n\n      if (!started) {\n        return;\n      }\n\n      var shouldDiscardFocusId = focusTreeId !== this.focusTreeId;\n      /**\n       * We first decide if the keyup event should be handled (to ensure the correct\n       * order of logging statements)\n       */\n\n      var responseAction = this._howToHandleKeyEvent(event, focusTreeId, componentId, key, options, KeyEventType.keyup);\n      /**\n       * We then add the keyup to our current combination - regardless of whether\n       * it's to be handled or not. We need to do this to ensure that if a handler\n       * function changes focus to a context that ignored events, the keyup event\n       * is not lost (leaving react hotkeys thinking the key is still pressed).\n       */\n\n\n      if (this.eventPropagator.isFirstPropagationStep(componentId) && currentCombination.isKeyIncluded(key)) {\n        this._addToAndLogCurrentKeyCombination(key, KeyEventType.keyup, focusTreeId, componentId, stateFromEvent(event));\n      }\n      /**\n       * We attempt to find a handler of the event, only if it has not already\n       * been handled and should not be ignored\n       */\n\n\n      if (responseAction === EventResponse.handled) {\n        this._callHandlerIfActionNotHandled(event, key, KeyEventType.keyup, componentId, focusTreeId);\n      }\n      /**\n       * We simulate any hidden keyup events hidden by the command key, regardless\n       * of whether the event should be ignored or not\n       */\n\n\n      this._simulateKeyUpEventsHiddenByCmd(event, key, focusTreeId, componentId, options);\n\n      this.eventPropagator.finishPropagationStep();\n      return shouldDiscardFocusId;\n    }\n    /**\n     * Closes any hanging key combinations that have not received the key event indicated\n     * by recordIndex.\n     * @param {KeyName} keyName The name of the key whose state should be updated if it\n     *        is currently set to keydown or keypress.\n     * @param {KeyEventType} recordIndex Index of key event to move the key state\n     *        up to.\n     */\n\n  }, {\n    key: \"closeHangingKeyCombination\",\n    value: function closeHangingKeyCombination(keyName, recordIndex) {\n      var currentCombination = this.getCurrentCombination();\n\n      if (currentCombination.isKeyIncluded(keyName) && !currentCombination.isEventTriggered(keyName, recordIndex)) {\n        /**\n         * If the key is in the current combination and recorded as still being pressed\n         * down (as either keydown or keypress), then we update the state\n         * to keypress or keyup (depending on the value of recordIndex).\n         */\n        currentCombination.setKeyState(keyName, recordIndex, KeyEventState.simulated);\n      }\n    }\n  }, {\n    key: \"_simulateKeyPressForNonPrintableKeys\",\n    value: function _simulateKeyPressForNonPrintableKeys(event, key, focusTreeId, componentId, options) {\n      this._handleEventSimulation('keypressEventsToSimulate', 'simulatePendingKeyPressEvents', this._shouldSimulate(KeyEventType.keypress, key), {\n        event: event,\n        key: key,\n        focusTreeId: focusTreeId,\n        componentId: componentId,\n        options: options\n      });\n    }\n  }, {\n    key: \"_simulateKeyUpEventsHiddenByCmd\",\n    value: function _simulateKeyUpEventsHiddenByCmd(event, key, focusTreeId, componentId, options) {\n      var _this2 = this;\n\n      if (isCmdKey(key)) {\n        this.getCurrentCombination().forEachKey(function (keyName) {\n          if (isCmdKey(keyName)) {\n            return;\n          }\n\n          _this2._handleEventSimulation('keyupEventsToSimulate', 'simulatePendingKeyUpEvents', _this2._shouldSimulate(KeyEventType.keyup, keyName), {\n            event: event,\n            key: keyName,\n            focusTreeId: focusTreeId,\n            componentId: componentId,\n            options: options\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_stopEventPropagation\",\n    value: function _stopEventPropagation(event, componentId) {\n      if (this.eventPropagator.stop(event)) {\n        this.logger.debug(this._logPrefix(componentId), 'Stopping further event propagation.');\n      }\n    }\n  }, {\n    key: \"getEventPropagator\",\n    value: function getEventPropagator() {\n      return this.eventPropagator;\n    }\n  }, {\n    key: \"_startAndLogNewKeyCombination\",\n    value: function _startAndLogNewKeyCombination(keyName, focusTreeId, componentId, keyEventState) {\n      this.getKeyHistory().startNewKeyCombination(keyName, keyEventState);\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId\n      }), \"Started a new combination with '\".concat(keyName, \"'.\"));\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId\n      }), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n  }, {\n    key: \"_addToAndLogCurrentKeyCombination\",\n    value: function _addToAndLogCurrentKeyCombination(keyName, keyEventType, focusTreeId, componentId, keyEventState) {\n      this.getKeyHistory().addKeyToCurrentCombination(keyName, keyEventType, keyEventState);\n\n      if (keyEventType === KeyEventType.keydown) {\n        this.logger.verbose(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Added '\".concat(keyName, \"' to current combination: '\").concat(this.getCurrentCombination().describe(), \"'.\"));\n      }\n\n      this.logger.verbose(this._logPrefix(componentId, {\n        focusTreeId: focusTreeId\n      }), \"Key history: \".concat(printComponent(this.getKeyHistory().toJSON()), \".\"));\n    }\n    /********************************************************************************\n     * Event simulation\n     ********************************************************************************/\n\n  }, {\n    key: \"_handleEventSimulation\",\n    value: function _handleEventSimulation(listName, handlerName, shouldSimulate, _ref) {\n      var event = _ref.event,\n          key = _ref.key,\n          focusTreeId = _ref.focusTreeId,\n          componentId = _ref.componentId,\n          options = _ref.options;\n\n      if (shouldSimulate && Configuration.option('simulateMissingKeyPressEvents')) {\n        /**\n         * If a key does not have a keypress event, we save the details of the keydown\n         * event to simulate the keypress event, as the keydown event bubbles through\n         * the last focus-only HotKeysComponent\n         */\n        var _event = this._cloneAndMergeEvent(event, {\n          key: key,\n          simulated: true\n        });\n\n        this[listName].push({\n          event: _event,\n          focusTreeId: focusTreeId,\n          componentId: componentId,\n          options: options\n        });\n      }\n\n      if (this.componentList.isRoot(componentId) || this.eventPropagator.isStopped()) {\n        if (!this.keyEventManager.isGlobalListenersBound()) {\n          this[handlerName]();\n        }\n        /**\n         * else, we wait for keydown event to propagate through global strategy\n         * before we simulate the keypress\n         */\n\n      }\n    }\n  }, {\n    key: \"simulatePendingKeyPressEvents\",\n    value: function simulatePendingKeyPressEvents() {\n      this._simulatePendingKeyEvents('keypressEventsToSimulate', 'handleKeyPress');\n    }\n  }, {\n    key: \"simulatePendingKeyUpEvents\",\n    value: function simulatePendingKeyUpEvents() {\n      this._simulatePendingKeyEvents('keyupEventsToSimulate', 'handleKeyUp');\n    }\n  }, {\n    key: \"_simulatePendingKeyEvents\",\n    value: function _simulatePendingKeyEvents(listName, handlerName) {\n      var _this3 = this;\n\n      if (this[listName].length > 0) {\n        KeyEventCounter.incrementId();\n      }\n\n      this[listName].forEach(function (_ref2) {\n        var event = _ref2.event,\n            focusTreeId = _ref2.focusTreeId,\n            componentId = _ref2.componentId,\n            options = _ref2.options;\n\n        _this3[handlerName](event, focusTreeId, componentId, options);\n      });\n      this[listName] = [];\n    }\n    /********************************************************************************\n     * Matching and calling handlers\n     ********************************************************************************/\n\n    /**\n     * Calls the first handler that matches the current key event if the action has not\n     * already been handled in a more deeply nested component\n     * @param {KeyboardEvent} event Keyboard event object to be passed to the handler\n     * @param {NormalizedKeyName} keyName Normalized key name\n     * @param {KeyEventType} keyEventType The record index of the current key event type\n     * @param {FocusTreeId} focusTreeId Id of focus tree component thinks it's apart of\n     * @param {ComponentId} componentId Index of the component that is currently handling\n     *        the keyboard event\n     * @private\n     */\n\n  }, {\n    key: \"_callHandlerIfActionNotHandled\",\n    value: function _callHandlerIfActionNotHandled(event, keyName, keyEventType, componentId, focusTreeId) {\n      var eventName = describeKeyEventType(keyEventType);\n      var combinationName = this.getCurrentCombination().describe();\n\n      if (!this.componentList.anyActionsForEventType(keyEventType)) {\n        this.logger.verbose(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" because it doesn't have any \").concat(eventName, \" handlers.\"));\n        return;\n      }\n\n      if (this.eventPropagator.isHandled()) {\n        this.logger.debug(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Ignored '\".concat(combinationName, \"' \").concat(eventName, \" as it has already been handled.\"));\n      } else {\n        this.logger.verbose(this._logPrefix(componentId, {\n          focusTreeId: focusTreeId\n        }), \"Attempting to find action matching '\".concat(combinationName, \"' \").concat(eventName, \" . . .\"));\n        var previousComponentPosition = this.eventPropagator.getPreviousPosition();\n        var componentPosition = this.componentList.getIndexById(componentId);\n\n        var handlerWasCalled = this._callClosestMatchingHandler(event, keyName, keyEventType, componentPosition, previousComponentPosition === -1 ? 0 : previousComponentPosition);\n\n        if (handlerWasCalled) {\n          this.eventPropagator.setHandled();\n        }\n      }\n    }\n    /********************************************************************************\n     * Logging\n     ********************************************************************************/\n\n  }, {\n    key: \"_logPrefix\",\n    value: function _logPrefix(componentId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var logIcons = Logger.logIcons;\n      var eventIcons = Logger.eventIcons;\n      var componentIcons = Logger.componentIcons;\n      var base = 'HotKeys (';\n\n      if (options.focusTreeId !== false) {\n        var focusTreeId = isUndefined(options.focusTreeId) ? this.focusTreeId : options.focusTreeId;\n        base += \"F\".concat(focusTreeId).concat(logIcons[focusTreeId % logIcons.length], \"-\");\n      }\n\n      if (options.eventId !== false) {\n        var eventId = isUndefined(options.eventId) ? KeyEventCounter.getId() : options.eventId;\n        base += \"E\".concat(eventId).concat(eventIcons[eventId % eventIcons.length], \"-\");\n      }\n\n      base += \"C\".concat(componentId).concat(componentIcons[componentId % componentIcons.length]);\n      var position = this.componentList.getIndexById(componentId);\n\n      if (!isUndefined(position)) {\n        base += \"-P\".concat(position).concat(componentIcons[position % componentIcons.length], \":\");\n      }\n\n      return \"\".concat(base, \")\");\n    }\n  }]);\n\n  return FocusOnlyKeyEventStrategy;\n}(AbstractKeyEventStrategy);\n\nexport default FocusOnlyKeyEventStrategy;","map":null,"metadata":{},"sourceType":"module"}