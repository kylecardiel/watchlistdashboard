{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyCombination from './KeyCombination';\n/**\n * List of key combinations seen by hot key components\n * @class\n */\n\nvar KeyHistory =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new KeyHistory instance\n   * @param {Number} maxLength Maximum length of the list.\n   * @param {KeyCombination} startingPoint Initial state of first combination\n   * @returns {KeyHistory}\n   */\n  function KeyHistory(_ref) {\n    var maxLength = _ref.maxLength;\n    var startingPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, KeyHistory);\n\n    this._records = [];\n    this._maxLength = maxLength;\n\n    if (startingPoint) {\n      this._push(startingPoint);\n    } else {\n      this._push(new KeyCombination());\n    }\n  }\n  /**\n   * A subset of the most recently press key combinations\n   * @param {Number} numberOfCombinations The number of most recent key combinations\n   * @returns {KeyCombination[]} List of key combinations\n   */\n\n\n  _createClass(KeyHistory, [{\n    key: \"getMostRecentCombinations\",\n    value: function getMostRecentCombinations(numberOfCombinations) {\n      return this._records.slice(-numberOfCombinations, -1);\n    }\n    /**\n     * Whether any keys have been stored in the key history\n     * @returns {boolean} true if there is at least one key combination, else false\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return this._records.some(function (keyCombination) {\n        return keyCombination.any();\n      });\n    }\n    /**\n     * The number of key combinations in the history (limited by the max length)\n     * @returns {number} Number of key combinations\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._records.length;\n    }\n    /**\n     * Most recent or current key combination\n     * @returns {KeyCombination} Key combination record\n     */\n\n  }, {\n    key: \"getCurrentCombination\",\n    value: function getCurrentCombination() {\n      return this._records[this.getLength() - 1];\n    }\n    /**\n     * Adds a key event to the current key combination (as opposed to starting a new\n     * keyboard combination).\n     * @param {ReactKeyName} keyName - Name of the key to add to the current combination\n     * @param {KeyEventType} recordIndex - Index in record to set to true\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"addKeyToCurrentCombination\",\n    value: function addKeyToCurrentCombination(keyName, recordIndex, keyEventState) {\n      this._ensureInitialKeyCombination();\n\n      this.getCurrentCombination().setKeyState(keyName, recordIndex, keyEventState);\n    }\n    /**\n     * Sets a new maximum length for the key combination history. Once the number of\n     * key combinations exceeds this length, the oldest is dropped.\n     * @param {Number} length New maximum length of the key history\n     */\n\n  }, {\n    key: \"setMaxLength\",\n    value: function setMaxLength(length) {\n      this._maxLength = length;\n\n      this._trimHistory();\n    }\n    /**\n     * Adds a new KeyCombination to the event history.\n     * @param {ReactKeyName} keyName - Name of the keyboard key to add to the new\n     *        KeyCombination\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"startNewKeyCombination\",\n    value: function startNewKeyCombination(keyName, keyEventState) {\n      this._ensureInitialKeyCombination();\n\n      var newCombinationRecord = new KeyCombination(this.getCurrentCombination().keysStillPressedDict());\n      newCombinationRecord.addKey(keyName, keyEventState);\n\n      this._push(newCombinationRecord);\n    }\n    /**\n     * A plain JavaScript representation of the key combination history, useful for\n     * serialization or debugging\n     * @returns {Object[]} Serialized representation of the registry\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._records.map(function (keyCombination) {\n        return keyCombination.toJSON();\n      });\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_ensureInitialKeyCombination\",\n    value: function _ensureInitialKeyCombination() {\n      if (this.getLength() === 0) {\n        this._push(new KeyCombination());\n      }\n    }\n  }, {\n    key: \"_push\",\n    value: function _push(record) {\n      this._trimHistory();\n\n      this._records.push(record);\n    }\n  }, {\n    key: \"_trimHistory\",\n    value: function _trimHistory() {\n      while (this.getLength() > this._maxLength) {\n        /**\n         * We know the longest key sequence registered for the currently focused\n         * components, so we don't need to keep a record of history longer than\n         * that\n         */\n        this._shift();\n      }\n    }\n  }, {\n    key: \"_shift\",\n    value: function _shift() {\n      this._records.shift();\n    }\n  }]);\n\n  return KeyHistory;\n}();\n\nexport default KeyHistory;","map":null,"metadata":{},"sourceType":"module"}