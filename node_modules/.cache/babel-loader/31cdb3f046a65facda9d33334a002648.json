{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport removeAtIndex from '../../utils/array/removeAtIndex';\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport Configuration from '../config/Configuration';\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\nimport isObject from '../../utils/object/isObject';\nimport hasKey from '../../utils/object/hasKey';\nimport arrayFrom from '../../utils/array/arrayFrom';\nimport isUndefined from '../../utils/isUndefined';\nimport KeyEventType from '../../const/KeyEventType';\nimport KeySequenceParser from '../shared/KeySequenceParser';\nimport KeyEventState from '../../const/KeyEventState';\nimport ComponentOptionsListIterator from './ComponentOptionsListIterator';\n/**\n * @typedef {Object} ComponentOptions a hotkeys component's options in a normalized\n *          format\n * @property {ActionDictionary} actions The dictionary of actions defined by the\n *           component\n */\n\n/**\n * A mapping between ActionName and ActionConfiguration\n * @typedef {Object.<ActionName,ActionConfiguration>} ActionDictionary\n */\n\n/**\n * Standardized format for defining an action\n * @typedef {Object} ActionConfiguration\n * @property {NormalizedKeySequenceId} prefix - String describing the sequence of key\n *          combinations, before the final key combination (an empty string for\n *          sequences that are a single key combination)\n * @property {ActionName} actionName - Name of the action\n * @property {number} sequenceLength - Number of combinations involved in the\n *           sequence\n * @property {KeyCombinationString} id - Serialized description of the key combinations\n *            that make up the sequence\n * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\n *           in the last key combination of the sequence\n * @property {KeyEventType} keyEventType - Record index for key event that\n *          the matcher should match on\n * @property {number} size - Number of keys involved in the final key combination\n */\n\n/**\n * List of component options that define the application's currently enabled key\n * maps and handlers, starting from the inner-most (most deeply nested) component,\n * that is closest to the DOM element currently in focus, and ending with the options\n * of the root hotkeys component.\n * @class\n */\n\nvar ComponentOptionsList =\n/*#__PURE__*/\nfunction () {\n  function ComponentOptionsList() {\n    _classCallCheck(this, ComponentOptionsList);\n    /**\n     * List of ComponentOptions for the actions registered by each hot keys component.\n     * @type {ComponentOptions[]}\n     */\n\n\n    this._list = [];\n    /**\n     * Dictionary mapping the ids of the components defining actions, and their\n     * position in the list.\n     * @type {Object.<ComponentId, Number>}\n     */\n\n    this._idToIndex = {};\n    /**\n     * Counter for the length of the longest sequence currently enabled.\n     * @type {number}\n     */\n\n    this._longestSequence = 1;\n    /**\n     * The id of the component with the longest key sequence\n     * @type {ComponentId}\n     */\n\n    this._longestSequenceComponentId = null;\n    /**\n     * Record of whether at least one keymap is bound to each event type (keydown,\n     * keypress or keyup)\n     * @type {KeyEvent}\n     */\n\n    this._keyMapEventRecord = KeyEventStateArrayManager.newRecord();\n  }\n  /**\n   * Return a new iterator that can be used to enumerate the list\n   * @returns {ComponentOptionsListIterator}\n   */\n\n\n  _createClass(ComponentOptionsList, [{\n    key: \"getNewIterator\",\n    value: function getNewIterator() {\n      return new ComponentOptionsListIterator(this);\n    }\n    /**\n     * Adds a new hot key component's options, to be parsed and standardised before being\n     * added to the list\n     * @param {ComponentId} componentId - Id of the component the options belong to\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\n     * @param {Object} options - Hash of options that configure how the key map is built.\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\n     *        action that does not explicitly define one.\n     * @returns {number} The position the component options have in the list\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\n      if (this.containsId(componentId)) {\n        return this.update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n      }\n\n      var componentOptions = this._build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      this._list.push(componentOptions);\n\n      var newIndex = this._getLastIndex();\n\n      return this._idToIndex[componentId] = newIndex;\n    }\n    /**\n     * Whether the list contains options for a component with the specified id\n     * @param {ComponentId} id Id of the component\n     * @returns {boolean} True if the list contains options for the component with the\n     *        specified id\n     */\n\n  }, {\n    key: \"containsId\",\n    value: function containsId(id) {\n      return !!this.get(id);\n    }\n    /**\n     * Retrieves options for a component from the list\n     * @param {ComponentId} id Id of the component to retrieve the options for\n     * @returns {ComponentOptions} Options for the component with the specified id\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      return this.getAtPosition(this.getIndexById(id));\n    }\n    /**\n     * Returns the position of the options belonging to the component with the specified\n     * id.\n     * @param {ComponentId} id Id of the component to retrieve the options for\n     * @returns {number} The position of the component options in the list.\n     */\n\n  }, {\n    key: \"getIndexById\",\n    value: function getIndexById(id) {\n      return this._idToIndex[id];\n    }\n    /**\n     * Replaces the options of a component already in the list with new values\n     * @param {ComponentId} componentId - Id of the component to replace the options of\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\n     * @param {Object} options - Hash of options that configure how the key map is built.\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\n     *        action that does not explicitly define one.\n     * @returns {number} The position the component options have in the list\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\n      /**\n       * We record whether we're building new options for the component that currently\n       * has the longest sequence, to decide whether we need to recalculate the longest\n       * sequence.\n       */\n      var isUpdatingLongestSequenceComponent = this._isUpdatingComponentWithLongestSequence(componentId);\n\n      var longestSequenceBefore = this.getLongestSequence();\n\n      var componentOptions = this._build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options);\n\n      if (isUpdatingLongestSequenceComponent && componentOptions.sequenceLength !== longestSequenceBefore) {\n        /**\n         * Component with the longest sequence has just had new options registered\n         * so we need to reset the longest sequence\n         */\n        if (componentOptions.sequenceLength > longestSequenceBefore) {\n          /**\n           * The same component has registered a longer sequence, so we just\n           * need to update the sequence length to the new, larger number\n           */\n          this._longestSequence = componentOptions.sequenceLength;\n        } else {\n          /**\n           * The component may no longer have the longest sequence, so we need to\n           * recalculate\n           */\n          this._recalculateLongestSequence();\n        }\n      }\n\n      this._list[this.getIndexById(componentId)] = componentOptions;\n    }\n    /**\n     * Removes the options of a component from the list\n     * @param {ComponentId} id The id of the component whose options are removed\n     * @returns {void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(id) {\n      var isUpdatingLongestSequenceComponent = this._isUpdatingComponentWithLongestSequence(id);\n\n      this.removeAtPosition(this.getIndexById(id));\n\n      if (isUpdatingLongestSequenceComponent) {\n        this._recalculateLongestSequence();\n      }\n    }\n    /**\n     * Whether the list has any options in it (non-empty)\n     * @returns {boolean} true if the list has one or more options in it\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return this.getLength() !== 0;\n    }\n    /**\n     * Whether a component is the root component (the last one in the list)\n     * @param {ComponentId} id Id of the component to query if it is the root\n     * @returns {boolean} true if the component is the last in the list\n     */\n\n  }, {\n    key: \"isRoot\",\n    value: function isRoot(id) {\n      return this.getIndexById(id) >= this.getLength() - 1;\n    }\n    /**\n     * The length of the longest sequence currently defined.\n     * @returns {number} The sequence length\n     */\n\n  }, {\n    key: \"getLongestSequence\",\n    value: function getLongestSequence() {\n      return this._longestSequence;\n    }\n    /**\n     * Whether the list contains at least one component with an action bound to a\n     * particular keyboard event type.\n     * @param {KeyEventType} keyEventType Index of the keyboard event type\n     * @returns {boolean} true when the list contains a component with an action bound\n     *          to the event type\n     */\n\n  }, {\n    key: \"anyActionsForEventType\",\n    value: function anyActionsForEventType(keyEventType) {\n      return !!this._keyMapEventRecord[keyEventType];\n    }\n    /**\n     * The number of components in the list\n     * @returns {number} Number of components in the list\n     */\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._list.length;\n    }\n    /**\n     * The component options at particular position in the list\n     * @param {number} position The position in the list\n     * @returns {ComponentOptions} The component options at the position in the list\n     */\n\n  }, {\n    key: \"getAtPosition\",\n    value: function getAtPosition(position) {\n      return this._list[position];\n    }\n    /**\n     * Remove the component options at a position in the list\n     * @param {number} position The position in the list to remove the options\n     * return {void}\n     */\n\n  }, {\n    key: \"removeAtPosition\",\n    value: function removeAtPosition(position) {\n      this._list = removeAtIndex(this._list, position);\n      var counter = position;\n\n      while (counter < this.getLength()) {\n        this._idToIndex[this.getAtPosition(counter).componentId] = counter;\n        counter++;\n      }\n    }\n    /**\n     * A plain JavaScript object representation of the component options list that can\n     * be used for serialization or debugging\n     * @returns {ComponentOptions[]} plain JavaScript object representation of the list\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._list;\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_getLastIndex\",\n    value: function _getLastIndex() {\n      return this.getLength() - 1;\n    }\n    /**\n     * Builds the internal representation that described the options passed to a hot keys\n     * component\n     * @param {ComponentId} componentId - Id of the component the options belong to\n     * @param {KeyMap} actionNameToKeyMap - Map of actions to key maps\n     * @param {HandlersMap} actionNameToHandlersMap - Map of actions to handlers\n     * @param {Object} options - Hash of options that configure how the key map is built.\n     * @returns {ComponentOptions} Options for the specified component\n     * @private\n     */\n\n  }, {\n    key: \"_build\",\n    value: function _build(componentId, actionNameToKeyMap, actionNameToHandlersMap, options) {\n      var _this$_applyHardSeque = this._applyHardSequences(actionNameToKeyMap, actionNameToHandlersMap),\n          hardSequenceKeyMap = _this$_applyHardSeque.keyMap,\n          includingHardSequenceHandlers = _this$_applyHardSeque.handlers;\n\n      var actions = this._buildActionDictionary(_objectSpread({}, actionNameToKeyMap, hardSequenceKeyMap), options, componentId);\n\n      return {\n        actions: actions,\n        handlers: includingHardSequenceHandlers,\n        componentId: componentId,\n        options: options\n      };\n    }\n  }, {\n    key: \"_isUpdatingComponentWithLongestSequence\",\n    value: function _isUpdatingComponentWithLongestSequence(componentId) {\n      return componentId === this._getLongestSequenceComponentId();\n    }\n  }, {\n    key: \"_getLongestSequenceComponentId\",\n    value: function _getLongestSequenceComponentId() {\n      return this._longestSequenceComponentId;\n    }\n  }, {\n    key: \"_recalculateLongestSequence\",\n    value: function _recalculateLongestSequence() {\n      var iterator = this.getNewIterator();\n\n      while (iterator.next()) {\n        var _iterator$getComponen = iterator.getComponent(),\n            longestSequence = _iterator$getComponen.longestSequence,\n            componentId = _iterator$getComponen.componentId;\n\n        if (longestSequence > this.getLongestSequence()) {\n          this._longestSequenceComponentId = componentId;\n          this._longestSequence = longestSequence;\n        }\n      }\n    }\n    /**\n     * Applies hard sequences (handlers attached to actions with names that are valid\n     * KeySequenceStrings) that implicitly define a corresponding action name.\n     * @param {KeyMap} actionNameToKeyMap - KeyMap specified by HotKeys component\n     * @param {HandlersMap} actionMap - HandlersMap specified by HotKeys component\n     * @returns {{keyMap: {}, handlers: {}}} Object containing keymap and handlers map\n     *        with the hard sequence actions applied\n     * @private\n     */\n\n  }, {\n    key: \"_applyHardSequences\",\n    value: function _applyHardSequences(actionNameToKeyMap, actionMap) {\n      if (Configuration.option('enableHardSequences')) {\n        return Object.keys(actionMap).reduce(function (memo, actionNameOrHardSequence) {\n          var actionNameIsInKeyMap = !!actionNameToKeyMap[actionNameOrHardSequence];\n\n          if (!actionNameIsInKeyMap && KeyCombinationSerializer.isValidKeySerialization(actionNameOrHardSequence)) {\n            memo.keyMap[actionNameOrHardSequence] = actionNameOrHardSequence;\n          }\n\n          memo.handlers[actionNameOrHardSequence] = actionMap[actionNameOrHardSequence];\n          return memo;\n        }, {\n          keyMap: {},\n          handlers: {}\n        });\n      } else {\n        return {\n          keyMap: actionNameToKeyMap,\n          handlers: actionMap\n        };\n      }\n    }\n    /**\n     * Returns a mapping between ActionNames and ActionConfiguration\n     * @param {KeyMap} actionNameToKeyMap - Mapping of ActionNames to key sequences.\n     * @param {Object} options - Hash of options that configure how the key map is built.\n     * @param {string} options.defaultKeyEvent - The default key event to use for any\n     *        action that does not explicitly define one.\n     * @param {ComponentId} componentId Index of the component the matcher belongs to\n     * @returns {ActionDictionary} Map from ActionNames to ActionConfiguration\n     * @private\n     */\n\n  }, {\n    key: \"_buildActionDictionary\",\n    value: function _buildActionDictionary(actionNameToKeyMap, options, componentId) {\n      var _this = this;\n\n      return Object.keys(actionNameToKeyMap).reduce(function (memo, actionName) {\n        var keyMapConfig = actionNameToKeyMap[actionName];\n\n        var keyMapOptions = function () {\n          if (isObject(keyMapConfig) && hasKey(keyMapConfig, 'sequences')) {\n            return arrayFrom(keyMapConfig.sequences);\n          } else {\n            return arrayFrom(keyMapConfig);\n          }\n        }();\n\n        keyMapOptions.forEach(function (keyMapOption) {\n          var _normalizeActionOptio = normalizeActionOptions(keyMapOption, options),\n              keySequence = _normalizeActionOptio.keySequence,\n              keyEventType = _normalizeActionOptio.keyEventType;\n\n          _this._addActionOptions(memo, componentId, actionName, keySequence, keyEventType);\n        });\n        return memo;\n      }, {});\n    }\n  }, {\n    key: \"_addActionOptions\",\n    value: function _addActionOptions(memo, componentId, actionName, keySequence, keyEventType) {\n      var _KeySequenceParser$pa = KeySequenceParser.parse(keySequence, {\n        keyEventType: keyEventType\n      }),\n          sequence = _KeySequenceParser$pa.sequence,\n          combination = _KeySequenceParser$pa.combination;\n\n      if (sequence.size > this.getLongestSequence()) {\n        this._longestSequence = sequence.size;\n        this._longestSequenceComponentId = componentId;\n      }\n      /**\n       * Record that there is at least one key sequence in the focus tree bound to\n       * the keyboard event\n       */\n\n\n      this._keyMapEventRecord[keyEventType] = KeyEventState.seen;\n\n      if (!memo[actionName]) {\n        memo[actionName] = [];\n      }\n\n      memo[actionName].push(_objectSpread({\n        prefix: sequence.prefix,\n        actionName: actionName,\n        sequenceLength: sequence.size\n      }, combination));\n    }\n  }]);\n\n  return ComponentOptionsList;\n}();\n\nfunction normalizeActionOptions(keyMapOption, options) {\n  if (isObject(keyMapOption)) {\n    var sequence = keyMapOption.sequence,\n        action = keyMapOption.action;\n    return {\n      keySequence: sequence,\n      keyEventType: isUndefined(action) ? KeyEventType[options.defaultKeyEvent] : KeyEventType[action]\n    };\n  } else {\n    return {\n      keySequence: keyMapOption,\n      keyEventType: KeyEventType[options.defaultKeyEvent]\n    };\n  }\n}\n\nexport default ComponentOptionsList;","map":null,"metadata":{},"sourceType":"module"}