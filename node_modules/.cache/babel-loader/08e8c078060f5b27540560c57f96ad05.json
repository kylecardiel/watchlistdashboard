{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Encapsulates all logging behaviour and provides the ability to specify the level\n * of logging desired.\n * @class\n */\n\n\nvar Logger =\n/*#__PURE__*/\nfunction () {\n  _createClass(Logger, [{\n    key: \"noop\",\n\n    /**\n     * Icons prefixed to the start of logging statements that cycled through each\n     * time a focus tree changes, making it easier to quickly spot events related\n     * to the same focus tree.\n     */\n\n    /**\n     * Icons prefixed to the start of logging statements that cycled through each\n     * time a component ID changes, making it easier to quickly spot events related\n     * to the same component.\n     */\n\n    /**\n     * Icons prefixed to the start of logging statements that cycled through each\n     * time an event ID changes, making it easier to quickly trace the path of KeyEvent\n     * objects as they propagate through multiple components.\n     */\n\n    /**\n     * The level of logging to perform\n     * @typedef {'none'|'error'|'warn'|'info'|'debug'|'verbose'} LogLevel\n     */\n\n    /**\n     * Levels of log severity - the higher the log level, the greater the amount (and\n     * lesser the importance) of information logged to the console about React HotKey's\n     * behaviour\n     * @enum {number} LogLevel\n     */\n    value: function noop() {}\n    /**\n     * By default, calls to all log severities are a no-operation. It's only when the\n     * user specifies a log level, are they replaced with logging statements\n     * @type {Logger.noop}\n     */\n\n  }]);\n\n  function Logger() {\n    var _this = this;\n\n    var logLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'warn';\n\n    _classCallCheck(this, Logger);\n\n    _defineProperty(this, \"verbose\", this.noop);\n\n    _defineProperty(this, \"debug\", this.noop);\n\n    _defineProperty(this, \"info\", this.noop);\n\n    _defineProperty(this, \"warn\", this.noop);\n\n    _defineProperty(this, \"error\", this.noop);\n\n    this.logLevel = this.constructor.levels[logLevel];\n\n    if (this.logLevel >= this.constructor.levels.error) {\n      this.error = console.error;\n    } else {\n      return;\n    }\n\n    if (this.logLevel >= this.constructor.levels.warn) {\n      this.warn = console.warn;\n    } else {\n      return;\n    }\n\n    ['info', 'debug', 'verbose'].some(function (logLevel) {\n      if (_this.logLevel >= _this.constructor.levels[logLevel]) {\n        _this[logLevel] = console.log;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return Logger;\n}();\n\n_defineProperty(Logger, \"logIcons\", ['📕', '📗', '📘', '📙']);\n\n_defineProperty(Logger, \"componentIcons\", ['🔺', '⭐️', '🔷', '🔶', '⬛️']);\n\n_defineProperty(Logger, \"eventIcons\", ['❤️', '💚', '💙', '💛', '💜', '🧡']);\n\n_defineProperty(Logger, \"levels\", {\n  none: 0,\n  error: 1,\n  warn: 2,\n  info: 3,\n  debug: 4,\n  verbose: 5\n});\n\nexport default Logger;","map":null,"metadata":{},"sourceType":"module"}