{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyEventSequenceIndex from '../../const/KeyEventSequenceIndex';\nimport KeyEventType from '../../const/KeyEventType';\nimport KeyCombinationSerializer from '../shared/KeyCombinationSerializer';\nimport resolveKeyAlias from '../../helpers/resolving-handlers/resolveKeyAlias';\nimport applicableAliasFunctions from '../../helpers/resolving-handlers/applicableAliasFunctions';\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport isEmpty from '../../utils/collection/isEmpty';\nimport size from '../../utils/collection/size';\nimport KeyEventState from '../../const/KeyEventState';\nimport dictionaryFrom from '../../utils/object/dictionaryFrom';\n/**\n * Record of one or more keys pressed together, in a combination\n * @class\n */\n\nvar KeyCombination =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new KeyCombination instance\n   * @param {Object.<ReactKeyName, Array.<KeyEventState[]>>} keys Dictionary\n   *        of keys\n   * @returns {KeyCombination}\n   */\n  function KeyCombination() {\n    var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, KeyCombination);\n\n    this._keys = keys;\n    this._includesKeyUp = false;\n\n    this._update();\n  }\n  /********************************************************************************\n   * Getters\n   *********************************************************************************/\n\n  /**\n   * List of ids (serialized representations) for the keys involved in the combination\n   * @returns {KeySequence[]} List of combination ids\n   */\n\n\n  _createClass(KeyCombination, [{\n    key: \"getIds\",\n    value: function getIds() {\n      return this._ids;\n    }\n    /**\n     * Dictionary mapping keys to their acceptable aliases. This includes \"shifted\" or\n     * \"alted\" key characters.\n     * @returns {Object.<ReactKeyName, ReactKeyName[]>}\n     */\n\n  }, {\n    key: \"getKeyAliases\",\n    value: function getKeyAliases() {\n      return this._keyAliases;\n    }\n    /**\n     * A normalized version of the key, achieved by comparing it to the list of known\n     * aliases for the keys in the combination\n     * @param {ReactKeyName} keyName Name of the key to normalize\n     * @returns {ReactKeyName} Normalized key name\n     */\n\n  }, {\n    key: \"getNormalizedKeyName\",\n    value: function getNormalizedKeyName(keyName) {\n      var keyState = this._keys[keyName];\n\n      if (keyState) {\n        return keyName;\n      } else {\n        var keyAlias = this._keyAliases[keyName];\n\n        if (keyAlias) {\n          return keyAlias;\n        } else {\n          return keyName;\n        }\n      }\n    }\n    /********************************************************************************\n     * Query attributes of entire combination\n     *********************************************************************************/\n\n    /**\n     * Number of keys involved in the combination\n     * @returns {number} Number of keys\n     */\n\n  }, {\n    key: \"getNumberOfKeys\",\n    value: function getNumberOfKeys() {\n      return size(this._keys);\n    }\n    /**\n     * Whether there are any keys in the combination\n     * @returns {boolean} true if there is 1 or more keys involved in the combination,\n     *          else false.\n     */\n\n  }, {\n    key: \"any\",\n    value: function any() {\n      return Object.keys(this._getKeyStates()).length > 0;\n    }\n    /**\n     * Whether any of the keys in the combination have been released\n     * @returns {boolean} true if at least 1 key has been released in the combination\n     */\n\n  }, {\n    key: \"isEnding\",\n    value: function isEnding() {\n      return this._includesKeyUp;\n    }\n    /**\n     * Whether there are any keys in the current combination still being pressed\n     * @returns {boolean} True if all keys in the current combination are released\n     */\n\n  }, {\n    key: \"hasEnded\",\n    value: function hasEnded() {\n      return isEmpty(this.keysStillPressedDict());\n    }\n    /********************************************************************************\n     * Adding & modifying key states\n     *********************************************************************************/\n\n    /**\n     * Add a new key to the combination (starting with a state of keydown)\n     * @param {ReactKeyName} keyName Name of key\n     * @param {KeyEventState} keyEventState State key is in\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addKey\",\n    value: function addKey(keyName, keyEventState) {\n      this._setKeyState(keyName, [KeyEventStateArrayManager.newRecord(), KeyEventStateArrayManager.newRecord(KeyEventType.keydown, keyEventState)]);\n    }\n    /**\n     * Adds a key event to the current key combination (as opposed to starting a new\n     * keyboard combination).\n     * @param {ReactKeyName} keyName - Name of the key to add to the current combination\n     * @param {KeyEventType} recordIndex - Index in record to set to true\n     * @param {KeyEventState} keyEventState The state to set the key event to\n     */\n\n  }, {\n    key: \"setKeyState\",\n    value: function setKeyState(keyName, recordIndex, keyEventState) {\n      var existingRecord = this._getKeyState(keyName);\n\n      if (this.isKeyIncluded(keyName)) {\n        var previous = KeyEventStateArrayManager.clone(existingRecord[1]);\n        var current = KeyEventStateArrayManager.clone(previous);\n        KeyEventStateArrayManager.setBit(current, recordIndex, keyEventState);\n\n        this._setKeyState(keyName, [previous, current]);\n      } else {\n        this.addKey(keyName, keyEventState);\n      }\n\n      if (recordIndex === KeyEventType.keyup) {\n        this._includesKeyUp = true;\n      }\n    }\n    /********************************************************************************\n     * Iteration and subsets\n     *********************************************************************************/\n\n    /**\n     * @callback forEachHandler\n     * @param {ReactKeyName} keyName Name of a key in the combination\n     * @returns {void}\n     */\n\n    /**\n     * Iterates over every key in the combination, calling an function with each\n     * key name\n     * @param {forEachHandler} handler Function to call with the name of each key\n     *        in the combination\n     * @returns {void}\n     */\n\n  }, {\n    key: \"forEachKey\",\n    value: function forEachKey(handler) {\n      return Object.keys(this._keys).forEach(handler);\n    }\n    /**\n     * @callback evaluator\n     * @param {ReactKeyName} keyName Name of a key in the combination\n     * @returns {boolean}\n     */\n\n    /**\n     * Whether at least one of the keys causes a evaluator function to return true\n     * @callback {evaluator} evaluator Function to evaluate each key\n     * @returns {boolean} Whether at least one key satisfies the evaluator\n     */\n\n  }, {\n    key: \"some\",\n    value: function some(evaluator) {\n      return Object.keys(this._keys).some(evaluator);\n    }\n    /**\n     * Dictionary of keys included in the combination record\n     * @returns {Object.<ReactKeyName, boolean>}\n     */\n\n  }, {\n    key: \"getKeyDictionary\",\n    value: function getKeyDictionary() {\n      return dictionaryFrom(Object.keys(this._getKeyStates()), true);\n    }\n    /**\n     * Returns a new KeyCombination without the keys that have been\n     * released (had the keyup event recorded). Essentially, the keys that are\n     * currently still pressed down at the time a key event is being handled.\n     * @returns {KeyCombination} New KeyCombination with all of the\n     *        keys with keyup events omitted\n     */\n\n  }, {\n    key: \"keysStillPressedDict\",\n    value: function keysStillPressedDict() {\n      var _this = this;\n\n      return Object.keys(this._keys).reduce(function (memo, keyName) {\n        if (_this.isKeyStillPressed(keyName)) {\n          memo[keyName] = _this._getKeyState(keyName);\n        }\n\n        return memo;\n      }, {});\n    }\n    /********************************************************************************\n     * Query individual keys\n     *********************************************************************************/\n\n    /**\n     * Whether key is in the combination\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination\n     */\n\n  }, {\n    key: \"isKeyIncluded\",\n    value: function isKeyIncluded(keyName) {\n      return !!this._getKeyState(keyName);\n    }\n    /**\n     * Whether key is in the combination and has yet to be released\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination and yet to be released\n     */\n\n  }, {\n    key: \"isKeyStillPressed\",\n    value: function isKeyStillPressed(keyName) {\n      return this.isEventTriggered(keyName, KeyEventType.keypress) && !this.isKeyReleased(keyName);\n    }\n    /**\n     * Whether key is in the combination and been released\n     * @param {ReactKeyName} keyName Name of key\n     * @returns {boolean} true if the key is in the combination and has been released\n     */\n\n  }, {\n    key: \"isKeyReleased\",\n    value: function isKeyReleased(keyName) {\n      return this.isEventTriggered(keyName, KeyEventType.keyup);\n    }\n    /**\n     * Whether an event has been recorded for a key yet\n     * @param {ReactKeyName} keyName Name of the key\n     * @param {KeyEventType} keyEventType Index of the event type\n     * @returns {boolean} true if the event has been recorded for the key\n     */\n\n  }, {\n    key: \"isEventTriggered\",\n    value: function isEventTriggered(keyName, keyEventType) {\n      return this._getKeyStateType(keyName, KeyEventSequenceIndex.current, keyEventType);\n    }\n    /**\n     * Whether an event has been previously recorded for a key (the second most recent\n     * event to occur for the key)\n     * @param {ReactKeyName} keyName Name of the key\n     * @param {KeyEventType} keyEventType Index of the event type\n     * @returns {boolean} true if the event has been previously recorded for the key\n     */\n\n  }, {\n    key: \"wasEventPreviouslyTriggered\",\n    value: function wasEventPreviouslyTriggered(keyName, keyEventType) {\n      return this._getKeyStateType(keyName, KeyEventSequenceIndex.previous, keyEventType);\n    }\n    /**\n     * Whether a keypress event is currently being simulated\n     * @param {ReactKeyName} keyName Name of the key\n     * @returns {boolean} true if the keypress event is currently being simulated for the\n     *        key\n     */\n\n  }, {\n    key: \"isKeyPressSimulated\",\n    value: function isKeyPressSimulated(keyName) {\n      return this._isKeyEventSimulated(keyName, KeyEventType.keypress);\n    }\n    /**\n     * Whether a keyup event is currently being simulated\n     * @param {ReactKeyName} keyName Name of the key\n     * @returns {boolean} true if the keyup event is currently being simulated for the\n     *        key\n     */\n\n  }, {\n    key: \"isKeyUpSimulated\",\n    value: function isKeyUpSimulated(keyName) {\n      return this._isKeyEventSimulated(keyName, KeyEventType.keyup);\n    }\n    /********************************************************************************\n     * Presentation\n     *********************************************************************************/\n\n    /**\n     * Return a serialized description of the keys in the combination\n     * @returns {KeySequence}\n     */\n\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      return this.getIds()[0];\n    }\n    /**\n     * A plain JavaScript representation of the key combination record, useful for\n     * serialization or debugging\n     * @returns {Object} Serialized representation of the combination record\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        keys: this._getKeyStates(),\n        ids: this.getIds(),\n        keyAliases: this.getKeyAliases()\n      };\n    }\n    /********************************************************************************\n     * Private methods\n     *********************************************************************************/\n\n  }, {\n    key: \"_getKeyStateType\",\n    value: function _getKeyStateType(keyName, keyStage, keyEventType) {\n      var keyState = this._getKeyState(keyName);\n\n      return keyState && keyState[keyStage][keyEventType];\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._ids = KeyCombinationSerializer.serialize(this._keys);\n      this._keyAliases = buildKeyAliases(this._keys);\n    }\n  }, {\n    key: \"_isKeyEventSimulated\",\n    value: function _isKeyEventSimulated(keyName, keyEventType) {\n      return this.isEventTriggered(keyName, keyEventType) === KeyEventState.simulated;\n    }\n  }, {\n    key: \"_getKeyStates\",\n    value: function _getKeyStates() {\n      return this._keys;\n    }\n  }, {\n    key: \"_getKeyState\",\n    value: function _getKeyState(keyName) {\n      var keyState = this._keys[keyName];\n\n      if (keyState) {\n        return keyState;\n      } else {\n        var keyAlias = this._keyAliases[keyName];\n\n        if (keyAlias) {\n          return this._keys[keyAlias];\n        }\n      }\n    }\n  }, {\n    key: \"_setKeyState\",\n    value: function _setKeyState(keyName, keyState) {\n      var keyAlias = this.getNormalizedKeyName(keyName);\n      this._keys[keyAlias] = keyState;\n\n      this._update();\n    }\n  }]);\n\n  return KeyCombination;\n}();\n\nfunction buildKeyAliases(keyDictionary) {\n  return Object.keys(keyDictionary).reduce(function (memo, keyName) {\n    resolveKeyAlias(keyName).forEach(function (normalizedKey) {\n      applicableAliasFunctions(keyDictionary).forEach(function (aliasFunction) {\n        aliasFunction(normalizedKey).forEach(function (keyAlias) {\n          if (keyAlias !== keyName || keyName !== normalizedKey) {\n            memo[keyAlias] = keyName;\n          }\n        });\n      });\n    });\n    return memo;\n  }, {});\n}\n\nexport default KeyCombination;","map":null,"metadata":{},"sourceType":"module"}