{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport KeyEventStateArrayManager from '../shared/KeyEventStateArrayManager';\nimport indexFromEnd from '../../utils/array/indexFromEnd';\nimport KeyCombinationMatcher from './KeyCombinationMatcher';\nimport KeyEventState from '../../const/KeyEventState';\n/**\n * Matches a KeyHistory to a list of pre-registered ActionConfiguration and\n * their corresponding handler functions\n * @class\n */\n\nvar KeyHistoryMatcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Returns a new instance of KeyMapMatcher\n   * @returns {KeyHistoryMatcher}\n   */\n  function KeyHistoryMatcher() {\n    _classCallCheck(this, KeyHistoryMatcher);\n\n    this._combinationMatchers = {};\n    this._eventRecord = KeyEventStateArrayManager.newRecord();\n  }\n  /**\n   * Adds a possible match that can be used to match key combination histories\n   * @param {ActionConfiguration} actionConfig The configuration object that\n   *        defines the action the possible match represents\n   * @param {Function} handler Function to call if the possible match is selected\n   *        when matching against a key combination history\n   * @returns {void}\n   */\n\n\n  _createClass(KeyHistoryMatcher, [{\n    key: \"addMatch\",\n    value: function addMatch(actionConfig, handler) {\n      var combinationMatcher = this._getOrCreateCombinationMatcher(actionConfig.prefix);\n\n      combinationMatcher.addMatch(actionConfig, handler);\n      /**\n       * Merge event records so we can quickly determine if a given component\n       * has any handlers bound to particular key events\n       */\n\n      KeyEventStateArrayManager.setBit(this._eventRecord, actionConfig.keyEventType, KeyEventState.seen);\n      /**\n       * Record the longest sequence length so we know to only check for sequences\n       * of that length or shorter for a particular component\n       */\n\n      if (!this._longestSequence || this._longestSequence < actionConfig.sequenceLength) {\n        this._longestSequence = actionConfig.sequenceLength;\n      }\n    }\n    /**\n     * Attempts to find a match from the list of possible matches previously registered\n     * for a given key event and key combination history\n     * @param {KeyHistory} keyHistory History to attempt to\n     *        find a match for\n     * @param {ReactKeyName} key Name of the key to find a match for\n     * @param {KeyEventType} keyEventType Type of event to find a match\n     * @returns {MatchingActionConfig|null} First MatchingActionOptions that matches\n     */\n\n  }, {\n    key: \"findMatch\",\n    value: function findMatch(keyHistory, key, keyEventType) {\n      var combinationMatcher = this._findCombinationMatcher(keyHistory);\n\n      if (combinationMatcher) {\n        return combinationMatcher.findMatch(keyHistory.getCurrentCombination(), keyHistory.getCurrentCombination().getNormalizedKeyName(key), keyEventType);\n      }\n\n      return null;\n    }\n    /**\n     * Whether a possible match has been registered for a key event type\n     * @param {KeyEventType} eventType Type of event\n     * @returns {boolean} true if at least one possible match has been registered for\n     *        the event\n     */\n\n  }, {\n    key: \"hasMatchesForEventType\",\n    value: function hasMatchesForEventType(eventType) {\n      return !!this._eventRecord[eventType];\n    }\n    /**\n     * The number of combinations involved for the ActionConfiguration with the longest\n     * key sequence\n     * @returns {number} Number of combinations in the longest sequence\n     */\n\n  }, {\n    key: \"getLongestSequence\",\n    value: function getLongestSequence() {\n      return this._longestSequence;\n    }\n    /********************************************************************************\n     * Presentation\n     ********************************************************************************/\n\n    /**\n     * A plain JavaScript representation of the KeyMapMatcher, useful for\n     * serialization or debugging\n     * @returns {Object} Serialized representation of the key map matcher\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this = this;\n\n      return Object.keys(this._combinationMatchers).reduce(function (memo, prefix) {\n        var combinationMatcher = _this._combinationMatchers[prefix];\n        memo[prefix] = combinationMatcher.toJSON();\n        return memo;\n      }, {});\n    }\n    /********************************************************************************\n     * Private methods\n     ********************************************************************************/\n\n  }, {\n    key: \"_getOrCreateCombinationMatcher\",\n    value: function _getOrCreateCombinationMatcher(prefix) {\n      if (!this._combinationMatchers[prefix]) {\n        this._combinationMatchers[prefix] = new KeyCombinationMatcher();\n      }\n\n      return this._combinationMatchers[prefix];\n    }\n  }, {\n    key: \"_findCombinationMatcher\",\n    value: function _findCombinationMatcher(keyHistory) {\n      var sequenceHistory = keyHistory.getMostRecentCombinations(this.getLongestSequence());\n\n      if (sequenceHistory.length === 0) {\n        return this._combinationMatchers[''];\n      }\n\n      var sequenceIds = sequenceHistory.map(function (keyCombination) {\n        return keyCombination.getIds();\n      });\n      var idSizes = sequenceIds.map(function (ids) {\n        return ids.length;\n      });\n      /**\n       * List of counters\n       * @type {number[]}\n       */\n\n      var indexCounters = new Array(sequenceIds.length).fill(0);\n      var triedAllPossiblePermutations = false;\n\n      while (!triedAllPossiblePermutations) {\n        var sequenceIdPermutation = indexCounters.map(function (sequenceIdIndex, index) {\n          return sequenceIds[index][sequenceIdIndex];\n        });\n        var candidateId = sequenceIdPermutation.join(' ');\n\n        if (this._combinationMatchers[candidateId]) {\n          return this._combinationMatchers[candidateId];\n        }\n\n        var incrementer = 0;\n        var carry = true;\n\n        while (carry && incrementer < indexCounters.length) {\n          var count = indexFromEnd(indexCounters, incrementer);\n          var newIndex = (count + 1) % (indexFromEnd(idSizes, incrementer) || 1);\n          indexCounters[indexCounters.length - (incrementer + 1)] = newIndex;\n          carry = newIndex === 0;\n\n          if (carry) {\n            incrementer++;\n          }\n        }\n\n        triedAllPossiblePermutations = incrementer === indexCounters.length;\n      }\n    }\n  }]);\n\n  return KeyHistoryMatcher;\n}();\n\nexport default KeyHistoryMatcher;","map":null,"metadata":{},"sourceType":"module"}