{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport stripSuperfluousWhitespace from '../../utils/string/stripSuperfluousWhitespace';\nimport standardizeKeyName from '../../helpers/parsing-key-maps/standardizeKeyName';\nimport isValidKey, { InvalidKeyNameError } from '../../helpers/parsing-key-maps/isValidKey';\n/**\n * Returns a normalized KeyCombinationString (with the key names in the combination\n * sorted in alphabetical order)\n * @param {KeyName[]} keys List of key names to sort and reconstitute as a\n *        KeyCombinationString\n * @returns {NormalizedKeyCombinationString} Normalized KeyCombinationString\n */\n\nfunction normalizedCombinationId(keys) {\n  return keys.sort().join('+');\n}\n/**\n * Parses KeySequenceStrings and returns KeySequenceOptions\n *\n * Used primarily to parse strings describing hot key sequences and combinations\n * so that they may be matched with key events when they occur.\n * @class\n */\n\n\nvar KeySequenceParser =\n/*#__PURE__*/\nfunction () {\n  function KeySequenceParser() {\n    _classCallCheck(this, KeySequenceParser);\n  }\n\n  _createClass(KeySequenceParser, null, [{\n    key: \"parse\",\n\n    /**\n     * @typedef {Object} BasicKeyCombination Object containing the basic information that\n     *          describes a key combination\n     * @property {KeyCombinationString} id - String description of keys involved in the key\n     *          combination\n     * @property {number} size - Number of keys involved in the combination\n     * @property {Object.<KeyName, Boolean>} keyDictionary - Dictionary of key names involved\n     *           in the key combination\n     * @property {KeyEventType} keyEventType - Record index for key event that\n     *          the matcher should match on\n     */\n\n    /**\n     * @typedef {string} KeySequenceString String describing a sequence of one or more key\n     * combinations with whitespace separating key combinations in the sequence and '+'\n     * separating keys within a key combination.\n     */\n\n    /**\n     * @typedef {KeySequenceString} NormalizedKeySequenceId key sequence id with all of the\n     * combination id's normalized\n     */\n\n    /**\n     * @typedef {Object} BasicKeySequence Object containing the basic information that\n     *          describes a key sequence\n     * @property {NormalizedKeySequenceId} prefix - Normalized key sequence id\n     * @property {number} size - Number of combinations involved in the sequence\n     */\n\n    /**\n     * @typedef {Object} KeySequenceObject Object containing description of a key sequence\n     *          to compared against key events\n     * @property {KeySequenceString} id Id describing key sequence used for matching against\n     *            key events\n     * @property {ComponentId} componentId Id associated with the HotKeys component\n     *          that registered the key sequence\n     * @property {BasicKeyCombination[]} sequence A list of key combinations involved in\n     *            the sequence\n     * @property {number} size Number of key combinations in the key sequence\n     * @property {KeyEventType} keyEventType Index that matches key event type\n     * @property {ActionName} actionName Name of the action that should be triggered if a\n     *           keyboard event matching the sequence and event type occur\n     */\n\n    /**\n     * @typedef {Object} KeySequenceOptions Object containing the results of parsing a\n     *          KeySequenceString\n     * @property {BasicKeyCombination} combination Properties of the final combination in\n     *        the sequence\n     * @property {BasicKeySequence} sequence Properties of the sequence of keys leading\n     *        up to the final combination\n     */\n\n    /**\n     * Parses a KeySequenceString and returns a KeySequenceOptions object containing\n     * information about the sequence in a format that is easier to query\n     * @param {KeySequenceString} sequenceString String describing a key sequence to\n     *        parse\n     * @param {Object} options Configuration object describing how the KeySequenceString\n     *        should be parsed.\n     * @param {KeyEventType} options.keyEventType Event record index indicating\n     *        what key event the sequence should match\n     * @param {boolean} options.ensureValidKeys Whether to throw an exception if an invalid\n     *        key name is found in the key combination string.\n     * @returns {KeySequenceOptions} Object containing information about the key\n     *        sequence described by the KeySequenceString\n     */\n    value: function parse(sequenceString) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var trimmedSequenceString = stripSuperfluousWhitespace(sequenceString);\n      var keyCombinationsArray = trimmedSequenceString.split(' ');\n\n      try {\n        var nonTerminalCombinations = keyCombinationsArray.slice(0, keyCombinationsArray.length - 1);\n        var terminalCombination = keyCombinationsArray[keyCombinationsArray.length - 1];\n        var prefix = nonTerminalCombinations.map(function (keyCombination) {\n          var keysInComboDict = parseCombination(keyCombination, options);\n          return normalizedCombinationId(Object.keys(keysInComboDict));\n        }).join(' ');\n        var keysInComboDict = parseCombination(terminalCombination, options);\n        var normalizedComboString = normalizedCombinationId(Object.keys(keysInComboDict));\n        var combination = {\n          id: normalizedComboString,\n          keyDictionary: keysInComboDict,\n          keyEventType: options.keyEventType,\n          size: Object.keys(keysInComboDict).length\n        };\n        return {\n          sequence: {\n            prefix: prefix,\n            size: nonTerminalCombinations.length + 1\n          },\n          combination: combination\n        };\n      } catch (InvalidKeyNameError) {\n        return {\n          sequence: null,\n          combination: null\n        };\n      }\n    }\n  }]);\n\n  return KeySequenceParser;\n}();\n/**\n * @typedef {string} KeyCombinationString String describing a combination of one or more\n * keys separated by '+'\n */\n\n/**\n * @typedef {KeyCombinationString} NormalizedKeyCombinationString key combination id where\n * the keys have been normalized (sorted in alphabetical order)\n */\n\n/**\n * @typedef {Object.<ReactKeyName, Boolean>} KeyDictionary Registry of the names\n * of keys in a particular combination, for easy/quick checking if a particular\n * key is in the key combination\n */\n\n/**\n * Parses a key combination string and returns the corresponding KeyDictionary\n * @param {KeyCombinationString} string Describes key combination\n * @param {Object} options Options hash of how the string should be parsed\n * @param {boolean} options.ensureValidKeys Whether to throw an exception if an invalid\n *        key name is found in the key combination string.\n * @returns {KeyDictionary} Dictionary of keys in the parsed combination\n */\n\n\nfunction parseCombination(string) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return string.replace(/^\\+|(\\s|[^+]\\+)\\+/, '$1plus').split('+').reduce(function (keyDictionary, keyName) {\n    var finalKeyName = standardizeKeyName(keyName);\n\n    if (options.ensureValidKeys) {\n      if (!isValidKey(finalKeyName)) {\n        throw new InvalidKeyNameError();\n      }\n    }\n\n    keyDictionary[finalKeyName] = true;\n    return keyDictionary;\n  }, {});\n}\n\nexport default KeySequenceParser;","map":null,"metadata":{},"sourceType":"module"}