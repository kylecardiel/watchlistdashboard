{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport dictionaryFrom from '../../utils/object/dictionaryFrom';\n/**\n * Default configuration values\n * @private\n */\n\nvar _defaultConfiguration = {\n  /**\n   * The level of logging of its own behaviour React HotKeys should perform.\n   * @type {LogLevel}\n   */\n  logLevel: 'warn',\n\n  /**\n   * Default key event key maps are bound to, if left unspecified\n   * @type {KeyEventName}\n   */\n  defaultKeyEvent: 'keydown',\n\n  /**\n   * The default component type to wrap HotKey components' children in, to provide\n   * the required focus and keyboard event listening for HotKeys to function\n   */\n  defaultComponent: 'div',\n\n  /**\n   * The default tabIndex value passed to the wrapping component used to contain\n   * HotKey components' children. -1 skips focusing the element when tabbing through\n   * the DOM, but allows focusing programmatically.\n   */\n  defaultTabIndex: '-1',\n\n  /**\n   * The HTML tags that React HotKeys should ignore key events from. This only works\n   * if you are using the default ignoreEventsCondition function.\n   * @type {String[]}\n   */\n  ignoreTags: ['input', 'select', 'textarea'],\n\n  /**\n   * Whether to allow hard sequences, or the binding of handlers to actions that have\n   * names that are valid key sequences, which implicitly define actions that are\n   * triggered by that key sequence\n   */\n  enableHardSequences: false,\n\n  /**\n   * Whether to ignore changes to keyMap and handlers props by default (this reduces\n   * a significant amount of unnecessarily resetting internal state)\n   *\n   * @type {boolean}\n   */\n  ignoreKeymapAndHandlerChangesByDefault: true,\n\n  /**\n   * The function used to determine whether a key event should be ignored by React\n   * Hotkeys. By default, keyboard events originating elements with a tag name in\n   * ignoreTags, or a isContentEditable property of true, are ignored.\n   *\n   * @type {Function<KeyboardEvent>}\n   */\n  ignoreEventsCondition: function ignoreEventsCondition(event) {\n    var target = event.target;\n\n    if (target && target.tagName) {\n      var tagName = target.tagName.toLowerCase();\n      return Configuration.option('_ignoreTagsDict')[tagName] || target.isContentEditable;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Whether to ignore repeated keyboard events when a key is being held down\n   * @type {boolean}\n   */\n  ignoreRepeatedEventsWhenKeyHeldDown: true,\n\n  /**\n   * Whether React HotKeys should simulate keypress events for the keys that do not\n   * natively emit them.\n   * @type {boolean}\n   */\n  simulateMissingKeyPressEvents: true,\n\n  /**\n   * Whether to call stopPropagation() on events after they are handled (preventing\n   * the event from bubbling up any further, both within React Hotkeys and any other\n   * event listeners bound in React).\n   *\n   * This does not affect the behaviour of React Hotkeys, but rather what happens to\n   * the event once React Hotkeys is done with it (whether it's allowed to propagate\n   * any further through the Render tree).\n   * @type {boolean}\n   */\n  stopEventPropagationAfterHandling: true,\n\n  /**\n   * Whether to call stopPropagation() on events after they are ignored (preventing\n   * the event from bubbling up any further, both within React Hotkeys and any other\n   * event listeners bound in React).\n   *\n   * This does not affect the behaviour of React Hotkeys, but rather what happens to\n   * the event once React Hotkeys is done with it (whether it's allowed to propagate\n   * any further through the Render tree).\n   * @type {boolean}\n   */\n  stopEventPropagationAfterIgnoring: true,\n\n  /**\n   * Whether to allow combination submatches - e.g. if there is an action bound to\n   * cmd, pressing shift+cmd will *not* trigger that action when\n   * allowCombinationSubmatches is false.\n   *\n   * @note This option is ignored for combinations involving command (Meta) and\n   *      submatches are <i>always</i> allowed because Meta hides keyup events\n   *      of other keys, so until Command is released, it's impossible to know\n   *      if one of the keys that has also been pressed has been released.\n   *      @see https://github.com/greena13/react-hotkeys/pull/207\n   * @type {boolean}\n   */\n  allowCombinationSubmatches: false,\n\n  /**\n   * A mapping of custom key codes to key names that you can then use in your\n   * key sequences\n   * @type {Object.<Number, KeyName>}\n   */\n  customKeyCodes: {}\n};\n\nvar _configuration = _objectSpread({}, _defaultConfiguration);\n/**\n * Turn our array of tags to ignore into a dictionary, for faster lookup\n */\n\n\n_configuration._ignoreTagsDict = dictionaryFrom(_configuration.ignoreTags, true);\n/**\n * Handles getting and setting global configuration values, that affect how\n * React Hotkeys behaves\n * @class\n */\n\nvar Configuration =\n/*#__PURE__*/\nfunction () {\n  function Configuration() {\n    _classCallCheck(this, Configuration);\n  }\n\n  _createClass(Configuration, null, [{\n    key: \"init\",\n\n    /**\n     * Merges the specified configuration options with the current values.\n     * @see _configuration\n     */\n    value: function init(configuration) {\n      var _this = this;\n\n      var ignoreTags = configuration.ignoreTags,\n          customKeyCodes = configuration.customKeyCodes;\n\n      if (ignoreTags) {\n        configuration._ignoreTagsDict = dictionaryFrom(configuration.ignoreTags);\n      }\n\n      if (customKeyCodes) {\n        configuration._customKeyNamesDict = dictionaryFrom(Object.values(configuration.customKeyCodes));\n      }\n\n      if (false) {\n        if (['verbose', 'debug', 'info'].indexOf(configuration.logLevel) !== -1) {\n          console.warn(\"React HotKeys: You have requested log level '\".concat(configuration.logLevel, \"' but for performance reasons, logging below severity level 'warning' is disabled in production. Please use the development build for complete logs.\"));\n        }\n      }\n\n      Object.keys(configuration).forEach(function (key) {\n        _this.set(key, configuration[key]);\n      });\n    }\n    /**\n     * Sets a single configuration value by name\n     * @param {string} key - Name of the configuration value to set\n     * @param {*} value - New value to set\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      _configuration[key] = value;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(key) {\n      _configuration[key] = _defaultConfiguration[key];\n    }\n    /**\n     * Gets a single configuration value by name\n     * @param {string} key - Name of the configuration value\n     * @returns {*} Configuration value\n     */\n\n  }, {\n    key: \"option\",\n    value: function option(key) {\n      return _configuration[key];\n    }\n  }]);\n\n  return Configuration;\n}();\n\nexport default Configuration;","map":null,"metadata":{},"sourceType":"module"}